Grammar:
    delimiter* Rule*
;

delimiter(-L):
    | space
    | comment
;

space(-L):
    [\s\n\t\r]+
;

comment(-L):
    '/*' AnySymbol*>> '*/'
;

Rule:
    RuleName={str}! Flags? delimiter* ':' delimiter* RuleBody ';' delimiter*
;

RuleName:
    ID
;

ID:
    [a-zA-Z_] [a-zA-Z_0-9]*
;

Flags:
    '(' Skip? (Lexeme | KeepSpaces)? ')'
;

Skip(L):
    '-'
;

Lexeme(L):
    'L'
;

KeepSpaces(L):
    'S'
;

RuleBody:
    '|'? delimiter* Statement ('|' delimiter* Statement)*
;

Statement:
    Expression+
;

Expression:
    Element FunctionCall? Quantifier? LookAhead? Cut? delimiter*
;

Element:
    | RuleName={str}
    | StringLiteral
    | RegexpLiteral
    | InlineRule
;

Quantifier:
    | '*'
    | '?'
    | '+'
    | '{' Count '}'
;

Count:
    | IntValue={str}
    | FunctionCall
;

IntValue:
    [0-9]+
;

FunctionCall:
    '={'! FunctionName={str} (',' FunctionName={str})* '}'
;

FunctionName:
    ID
;

LookAhead:
    | '>>'
    | '>' Element
;

Cut:
    '!'
;

InlineRule:
    '('! RuleBody ')'
;

StringLiteral:
    '\''! Symbol={symbolStr}+>> '\''
;

RegexpLiteral:
    | '['! SymbolRange+>> ']'
    | AnySymbolLiteral
;

SymbolRange:
    Symbol={symbolStr}>']' ('-'! Symbol={symbolStr}>']')?
;

Symbol:
    | HexCodeSymbol
    | EscapedSymbol
    | AnySymbol
;

HexCodeSymbol:
    '\\x'! HexDigit HexDigit
;

HexDigit:
    [0-9A-F]
;

EscapedSymbol:
    '\\'! AnySymbol
;

AnySymbol(L):
    .
;

AnySymbolLiteral:
    '.'
;
