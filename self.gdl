Grammar:
    delimiter* Rule*
;

delimiter(-L):
    | space
    | comment
;

space(-L):
    [\s\n\t\r]+
;

comment(-L):
    '/*' AnySymbol*>> '*/'
;

Rule:
    RuleName! Flags? delimiter* ':' delimiter* RuleBody ';' delimiter*
;

RuleName(L):
    ID
;

ID(L):
    [a-zA-Z_] [a-zA-Z_0-9]*
;

Flags:
    '(' Skip? (Lexeme | KeepSpaces)? ')'
;

Skip(L):
    '-'
;

Lexeme(L):
    'L'
;

KeepSpaces(L):
    'S'
;

RuleBody:
    '|'? delimiter* Statement ('|' delimiter* Statement)*
;

Statement:
    Expression+
;

Expression:
    Element FunctionCall? Quantifier? LookAhead? Cut? delimiter*
;

Element:
    | RuleName
    | StringLiteral
    | RegexpLiteral
    | InlineRule
;

Quantifier:
    | '*'
    | '?'
    | '+'
    | '{' Count '}'
;

Count:
    | IntValue
    | FunctionCall
;

IntValue(L):
    [0-9]+
;

FunctionCall:
    '={'! FunctionName (',' FunctionName)* '}'
;

FunctionName(L):
    ID
;

LookAhead:
    | '>>'
    | '>' Element
;

Cut(L):
    '!'
;

InlineRule:
    '('! RuleBody ')'
;

StringLiteral:
    '\''! Symbol={symbolStr}+>> '\''
;

RegexpLiteral:
    | '['! SymbolRange+>> ']'
    | AnySymbolLiteral
;

SymbolRange:
    Symbol={symbolStr}>']' ('-'! Symbol={symbolStr}>']')?
;

Symbol:
    | HexCodeSymbol
    | EscapedSymbol
    | AnySymbol
;

HexCodeSymbol:
    '\\x'! HexDigit HexDigit
;

HexDigit(L):
    [0-9A-F]
;

EscapedSymbol:
    '\\'! AnySymbol
;

AnySymbol(L):
    .
;

AnySymbolLiteral:
    '.'
;
